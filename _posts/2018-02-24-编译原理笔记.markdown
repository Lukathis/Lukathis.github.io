---
layout: post
title:  "编译原理笔记"
---

# 2. 第一单元： 编译器介绍

## Overview

    |---源---|-----------------前端-----------------|----后端----|

    **源程序** --> **词法分析器** --> *记号流*

              --> **语法分析器** --> *抽象语法树*

              --> **语义分析器** -----------------> *中间表示*       

---

# 3. 第三单元：词法分析

## 3.1 [XC]Overview

  **RE** -1.Thompson算法-> **NFA** -2.子集构造算法-> **DFA** -3.Hopcroft最小化算法 -> **词法分析器代码**

## 3.2 子集构造算法

[XC] 子集构造算法作用 TODO

    q0 <- eps_closure(n0) // 计算起始点的闭包，确定DFA的起始节点的边界
    Q <- {q0}
    workList <- q0 // worklist可以使用队列实现
    while (workList != [])
      remove q from workList
      foreach (character c)
        t <- eps_closure(delta(q, c))
        D[q, c] <- t
        if (t not in Q)
          add t to Q and workList

## 3.3 DFA的最小化

  在将NFA转换为DFA时，有不止一种表达形式，而DFA的最小化目的在于求出最小的等价DFA形式。

### Hopcroft算法

[XC] Hopcroft算法思路 TODO

    // 基于等价类的思想
    split(S)                          // S为状态的集合，对其进行切分
      foreach (character c)           // c如果为ASCII的话循环256次
        if (c can split S)            // 在S用c进行处理后，可以切分成多个子集
          split S into T1, ..., Tk   

    hopcroft()
      split all nodes into N, A       // 最开始，N为非接受状态，A为接受状态
      while (set is still changes)
        split(S)


## 3.3 DFA的代码表示

### DFA的代码表示

 * 概念上讲，DFA是一个有向图
 * 实际上，有不同的DFA的代码表示。如转移表（类似邻接矩阵）、哈希表、跳转表
 * 取决于在实际实践中，对时间和空间的权衡

### (1) 转移表

转移表示例如下，如此表达后可以在编码时利用二维数组来表达这个表。状态，即列数根据状态图可以确定，有多少个状态。而字符的可能性由编码确定，如果是ASCII码，则有256种可能性。

Chart:

| 状态\字符 | a | b | c |
|:--------:|:-:|:-:|:-:|
|   0      | 1 |   |   |
|1 (ACCEPT)|   | 1 | 1 |


Code:

    char table[M][N]
    table[0]['a'] = 1;
    table[1]['b'] = 1;
    table[1]['c'] = 1;
    // other table entries are ERROR, like -1

有了转移表之后，可以转换到词法分析驱动代码： 转移表 <=> 词法分析驱动代码

Code:

    nextToken()
      state = 0             // 当前自动机中目前走到的状态，此处初始状态为0
      stack = []            // 初始化为空，目的是为了实现最长匹配，在识别标识符时很有效
      while (state != ERROR)
        c = getChar()
        if (state is ACCEPT
          clear(stack)
        stack.push(state)
        state = table[state][c]

      while (state is not ACCEPT) // 在匹配完成后往前走，但匹配不了，则回滚到最近的接受状态
        state = stack.pop()
        rollback()          // 将读入的无法匹配的值扔回字符串

### (2) 跳转表(jump table)

思路：跳转表拓扑结构与自动机拓扑结构相同，跳转表把每个状态变成一段代码，把状态直接边的转移变成一个显式的跳转，每个代码段负责识别当前状态上所能识别的所有字符和转换

Code:

    nextToken()
      state = 0
      stack = []
      goto q0

    q0:
      c = getChar()
      if (state is ACCEPT)
        clear(stack)
      stack.push(state)
      if (c == 'a')
        goto q1

    q1:
      c = getChar()
      if (state is ACCEPT)
        clear(stack)
      stack.push(state)
        if (c == 'b' || c == 'c')
        goto q1

跳转表优点： 不需要维护巨大的状态表，如果字符为Unicode，转移表会有上万个列，会占很大空间，flex采用跳转表。
需要根据实际使用场景确定采用哪种算法更优。


---

# 4. 第四单元： 语法分析

## Overview


## 4.1 语法分析的任务

* 早期语法分析器：分析源程序语言是否合法。
* 后期语法分析器：生成抽象语法树（后端核心数据结构），交给语义分析器等进行更为复杂的处理。
* 总的工作：*INPUT-记号流* --> **语法分析器** --> *OUTPUT-抽象语法树*
* 实际上输入除了记号流之外，还有一个输入就是 *语言的语法规则*，取决于我们编译器为哪门语言而写。可以理解为一个输入是文章，另一个是判断文章是否合法的字典。

路线图：
* 数学理论：上下文无关问法(CFG)
  - 描述语言语法规则的数学工具
* 自顶向下分析算法
  - 递归下向分析算法（预测分析算法）
  - LL分析算法
* 自底向上分析算法
  - LR分析算法


## 4.2 上下文无关文法与推导
