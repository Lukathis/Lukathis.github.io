I">^<h1 id="2-第一单元-编译器介绍">2. 第一单元： 编译器介绍</h1>

<h2 id="overview">Overview</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|---源---|-----------------前端-----------------|----后端----|

**源程序** --&gt; **词法分析器** --&gt; *记号流*

          --&gt; **语法分析器** --&gt; *抽象语法树*

          --&gt; **语义分析器** -----------------&gt; *中间表示*       
</code></pre></div></div>

<hr />

<h1 id="3-第三单元词法分析">3. 第三单元：词法分析</h1>

<h2 id="31-xcoverview">3.1 [XC]Overview</h2>

<p><strong>RE</strong> -1.Thompson算法-&gt; <strong>NFA</strong> -2.子集构造算法-&gt; <strong>DFA</strong> -3.Hopcroft最小化算法 -&gt; <strong>词法分析器代码</strong></p>

<h2 id="32-子集构造算法">3.2 子集构造算法</h2>

<p>[XC] 子集构造算法作用 TODO</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q0 &lt;- eps_closure(n0) // 计算起始点的闭包，确定DFA的起始节点的边界
Q &lt;- {q0}
workList &lt;- q0 // worklist可以使用队列实现
while (workList != [])
  remove q from workList
  foreach (character c)
    t &lt;- eps_closure(delta(q, c))
    D[q, c] &lt;- t
    if (t not in Q)
      add t to Q and workList
</code></pre></div></div>

<h2 id="33-dfa的最小化">3.3 DFA的最小化</h2>

<p>在将NFA转换为DFA时，有不止一种表达形式，而DFA的最小化目的在于求出最小的等价DFA形式。</p>

<h3 id="hopcroft算法">Hopcroft算法</h3>

<p>[XC] Hopcroft算法思路 TODO</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 基于等价类的思想
split(S)                          // S为状态的集合，对其进行切分
  foreach (character c)           // c如果为ASCII的话循环256次
    if (c can split S)            // 在S用c进行处理后，可以切分成多个子集
      split S into T1, ..., Tk   

hopcroft()
  split all nodes into N, A       // 最开始，N为非接受状态，A为接受状态
  while (set is still changes)
    split(S)
</code></pre></div></div>

<h2 id="33-dfa的代码表示">3.3 DFA的代码表示</h2>

<h3 id="dfa的代码表示">DFA的代码表示</h3>

<ul>
  <li>概念上讲，DFA是一个有向图</li>
  <li>实际上，有不同的DFA的代码表示。如转移表（类似邻接矩阵）、哈希表、跳转表</li>
  <li>取决于在实际实践中，对时间和空间的权衡</li>
</ul>

<h3 id="1-转移表">(1) 转移表</h3>

<p>转移表示例如下，如此表达后可以在编码时利用二维数组来表达这个表。状态，即列数根据状态图可以确定，有多少个状态。而字符的可能性由编码确定，如果是ASCII码，则有256种可能性。</p>

<p>Chart:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">状态\字符</th>
      <th style="text-align: center">a</th>
      <th style="text-align: center">b</th>
      <th style="text-align: center">c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">1 (ACCEPT)</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>Code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char table[M][N]
table[0]['a'] = 1;
table[1]['b'] = 1;
table[1]['c'] = 1;
// other table entries are ERROR, like -1
</code></pre></div></div>

<p>有了转移表之后，可以转换到词法分析驱动代码： 转移表 &lt;=&gt; 词法分析驱动代码</p>

<p>Code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nextToken()
  state = 0             // 当前自动机中目前走到的状态，此处初始状态为0
  stack = []            // 初始化为空，目的是为了实现最长匹配，在识别标识符时很有效
  while (state != ERROR)
    c = getChar()
    if (state is ACCEPT
      clear(stack)
    stack.push(state)
    state = table[state][c]

  while (state is not ACCEPT) // 在匹配完成后往前走，但匹配不了，则回滚到最近的接受状态
    state = stack.pop()
    rollback()          // 将读入的无法匹配的值扔回字符串
</code></pre></div></div>

<h3 id="2-跳转表jump-table">(2) 跳转表(jump table)</h3>

<p>思路：跳转表拓扑结构与自动机拓扑结构相同，跳转表把每个状态变成一段代码，把状态直接边的转移变成一个显式的跳转，每个代码段负责识别当前状态上所能识别的所有字符和转换</p>

<p>Code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nextToken()
  state = 0
  stack = []
  goto q0

q0:
  c = getChar()
  if (state is ACCEPT)
    clear(stack)
  stack.push(state)
  if (c == 'a')
    goto q1

q1:
  c = getChar()
  if (state is ACCEPT)
    clear(stack)
  stack.push(state)
    if (c == 'b' || c == 'c')
    goto q1
</code></pre></div></div>

<p>跳转表优点： 不需要维护巨大的状态表，如果字符为Unicode，转移表会有上万个列，会占很大空间，flex采用跳转表。
需要根据实际使用场景确定采用哪种算法更优。</p>

<hr />

<h1 id="4-第四单元-语法分析i">4. 第四单元： 语法分析I</h1>

<h2 id="overview-1">Overview</h2>

<h2 id="41-语法分析的任务">4.1 语法分析的任务</h2>

<ul>
  <li>早期语法分析器：分析源程序语言是否合法。</li>
  <li>后期语法分析器：生成抽象语法树（后端核心数据结构），交给语义分析器等进行更为复杂的处理。</li>
  <li>总的工作：<em>INPUT-记号流</em> –&gt; <strong>语法分析器</strong> –&gt; <em>OUTPUT-抽象语法树</em></li>
  <li>实际上输入除了记号流（句子s）之外，还有一个输入就是 <em>语言的语法规则</em>（即后面会提到的语法规则G），取决于我们编译器为哪门语言而写。可以理解为一个输入是文章，另一个是判断文章是否合法的字典。</li>
  <li>语法分析器的工作就是回答输入的记号流能否由语法规则G产生，回答一个yes/no的问题，如果可以，生成相应的语法树。</li>
</ul>

<p>路线图：</p>
<ul>
  <li>数学理论：上下文无关问法(CFG)
    <ul>
      <li>描述语言语法规则的数学工具</li>
    </ul>
  </li>
  <li>自顶向下分析算法
    <ul>
      <li>递归下向分析算法（预测分析算法）</li>
      <li>LL分析算法</li>
    </ul>
  </li>
  <li>自底向上分析算法
    <ul>
      <li>LR分析算法</li>
    </ul>
  </li>
</ul>

<h2 id="42-上下文无关文法与推导">4.2 上下文无关文法与推导</h2>

<h3 id="历史背景乔姆斯基文法体系">历史背景：乔姆斯基文法体系</h3>

<ul>
  <li>乔姆斯基为研究自然语言构造的一系列数学工具，目前已经应用到研究计算机语言中</li>
  <li>给出了从0到3的四种文法
    <ul>
      <li>3型文法：正则文法（可以用来描述语言的词法结构）</li>
      <li>2型文法：上下文无关文法（可以用来描述语言的语法结构）</li>
      <li>1型文法：上下文有关文法(计算机领域未广泛运用)</li>
      <li>0型文法：任意文法(计算机领域未广泛运用)</li>
    </ul>
  </li>
  <li>3型 -&gt; 2型 -&gt; 1型 -&gt; 0型，前一个为后一个的子集，越往后表达能力越强</li>
</ul>

<h3 id="示例">示例：</h3>

<ul>
  <li>自然语言中的句子典型结构：
    <ul>
      <li>主语 谓语 宾语</li>
      <li>名词 动词 名词</li>
    </ul>
  </li>
  <li>例子：
    <ul>
      <li>名词：{羊、老虎、草、水}</li>
      <li>动词：{吃、喝}</li>
    </ul>
  </li>
  <li>句子：
    <ul>
      <li>羊吃草、羊喝水、羊吃老虎、老虎吃羊…</li>
      <li>符合语法规则，但有些并不合逻辑</li>
    </ul>
  </li>
</ul>

<h3 id="形式化">形式化：</h3>

<ul>
  <li>符号：
    <ul>
      <li>非终结符：{S, V, N}</li>
      <li>终结符号：{s, t, g, w, e, d}</li>
      <li>开始符号：{S}</li>
      <li>非终结符一般使用大写，终结符一般使用小写，从而可以简化表达形式</li>
    </ul>
  </li>
  <li>
    <p>上述句型的形式化表达：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; N V N  // 名词 动词 名次，如羊吃草
N -&gt; s
   | t
   | g
   | w
V -&gt; e
   | d
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="上下文无关文法的数学定义">上下文无关文法的数学定义</h3>

<p>（从例子中抽象，不要过于纠结于形式化的内容）</p>

<p>上下文无关文法G是一个四元组：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  G = (T, N, P, S)
</code></pre></div></div>

<ul>
  <li>T：终结符集合</li>
  <li>N：非终结符集合</li>
  <li>P：产生式规则的集合，每条规则的形式都是：非终结符-&gt;终结符/非终结符</li>
  <li>S：唯一的开始符号</li>
</ul>

<p>在此定义上述例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G = (N, T, P, S)

N = {S, N, V}
T = {s, t, g, w, e, d}
S = S
P = {
    S -&gt; N V N
    N -&gt; s
       | t
       | g
       | w
    V -&gt; e
       | d
}
</code></pre></div></div>

<p>若以算术表达式为例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G = (N, T, P, S)

N = {E}
T = {num, id, +, \*}
S = E
P = {
    E -&gt; num
    E -&gt; id
    E -&gt; E + E
    E -&gt; E * E
}
</code></pre></div></div>

<p><em>注：很多情况下我们看到的是BNF范式，要求非终结符放到一对尖括号中，终结符要加上下划线，
从而区分终结符和非终结符</em></p>

<h3 id="推导">推导</h3>

<ul>
  <li>给定文法G，从G的开始符号S开始，用产生式的右部替换左侧的非终结符</li>
  <li>此过程不断重复，直到不出现非终结符为止</li>
  <li>最终的串称为句子</li>
</ul>

<h3 id="最左推导和最右推导">最左推导和最右推导</h3>

<ul>
  <li>最左推导：每次总是选择最左侧的符号进行替换</li>
  <li>最右推导：每次总是选择最右侧的符号进行替换</li>
</ul>

<h3 id="语法分析">语法分析：</h3>

<p>给定文法G和句子s，语法分析要回答的问题：是否存在对句子s的推导。</p>

<h2 id="43-分析树和二义性文法">4.3 分析树和二义性文法</h2>

<h3 id="分析树">分析树</h3>

<ul>
  <li>推导可以表达成树状结构，和推导所用的顺序无关（最左、最右、其他）</li>
  <li>特点：
    <ul>
      <li>树中的每个 <strong>内部节点</strong> 代表非终结符</li>
      <li>每个 <strong>叶子节点</strong> 代表终结符</li>
      <li>每一步 <strong>推导</strong> 代表如何从双亲节点生成它的直接孩子节点</li>
    </ul>
  </li>
  <li>
    <p>例子：
    E -&gt; num
       | id
       | E + E
       | E * E
分析 3 + 4 * 5</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 最左推导，先算加法
E -&gt; E + E
  -&gt; 3 + E
  -&gt; 3 + E * E
  -&gt; 3 + 4 * E
  -&gt; 3 + 4 * 5
// 另一种最左推导，先算乘法，有问题
E -&gt; E * E
  -&gt; E + E * E
  -&gt; 3 + E * E
  -&gt; 3 + 4 * E
  -&gt; 3 + 4 * 5
</code></pre></div>    </div>
  </li>
  <li>上述文法G存在一定问题：存在歧义（二义性）</li>
</ul>

<h3 id="二义性文法">二义性文法</h3>

<ul>
  <li>给定文法G，如果存在句子s，它有两棵不同的分析树，那么称G是二义性文法</li>
  <li>从编译器角度，二义性文法存在的问题：
    <ul>
      <li>同一个程序会有不同含义</li>
      <li>因此程序运行的结果不是唯一的</li>
    </ul>
  </li>
  <li>解决方案：<strong>文法的重写</strong></li>
</ul>

<h3 id="表达式文法的重写">表达式文法的重写</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  E -&gt; E + T        // T: term, T + T + T + ...
     | T
  T -&gt; T * F        // F: factor, F + F + F + ...
     | F
  F -&gt; num          // atom
     | id
</code></pre></div></div>

<p>推导：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  E -&gt; E + T        // 左递归满足左结合
    -&gt; T + T
    -&gt; F + T
    -&gt; 3 + T
    -&gt; 3 + T * F
    -&gt; 3 + F * F
    -&gt; 3 + 4 * F
    -&gt; 3 + 4 * 5
</code></pre></div></div>

<h2 id="44-自顶向下分析">4.4 自顶向下分析</h2>

<h3 id="自顶向下分析的算法思想">自顶向下分析的算法思想</h3>

<ul>
  <li>语法分析：给定文法G和句子s，回答s是否能够从G推导出来？</li>
  <li>基本算法思想：从G的开始符号出发，随意推导出某个句子t，比较t和s
    <ul>
      <li>若t==s，则回答“是”</li>
      <li>若t!=s，则继续推导(回溯)，遍历后看是否符合</li>
    </ul>
  </li>
  <li>因为这是从开始符号出发推出句子，因此称为自顶向下分析
    <ul>
      <li>对应于分析树自顶向下的构造顺序</li>
      <li>因为可能需要遍历，是很昂贵的算法</li>
    </ul>
  </li>
</ul>

<h3 id="算法伪代码描述">算法伪代码描述</h3>

<p>这个算法很深刻，用栈显式地实现了一个非递归版本的递归下降分析（非递归版本的树的遍历问题）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  tokens[]          // 句子s在词法分析后所有tokens
  i = 0
  stack = [S]       // S是文法的开始符号
  while (stack != [])
    if (stack[top] is a terminal t)
      if (t == tokens[i++])
        pop();
      else backtrack()
    else if (stack[top] is a nonterminal T)
      pop()
      push(the next right hand side of T)   // 从右向左开始压栈，其实是实现树的后序遍历
</code></pre></div></div>

<h3 id="算法的讨论">算法的讨论</h3>

<ul>
  <li>算法需要用到回溯，给分析效率带来问题</li>
  <li>而就这部分而言，编译器必须高效</li>
  <li>实际上我们需要线性时间的算法
    <ul>
      <li>避免回溯</li>
      <li>改进方法：<strong>递归下降分析算法</strong> 和 <strong>LL1分析算法</strong></li>
    </ul>
  </li>
</ul>

<h3 id="重新思考">重新思考</h3>

<ul>
  <li>避免回溯 -&gt; 用前看符号避免回溯（偷看一眼输入串s，看开头符号是否有符合的）</li>
  <li>但还是存在问题：
    <ul>
      <li>跟前看符号相同的匹配可能不止一个</li>
      <li>匹配不符合仍需要回溯</li>
    </ul>
  </li>
</ul>

<h2 id="45-递归下降分析算法">4.5 递归下降分析算法</h2>

<h3 id="overview-2">Overview</h3>

<p>递归下降分析算法只是自顶向下分析的其中一类。</p>

<ul>
  <li>也称为预测分析
    <ul>
      <li>分析高效（线性时间）</li>
      <li>容易实现（方便手工编码）</li>
      <li>错误定位和诊断信息准确</li>
      <li>被很多开源和商业的编译器采用：GCC4.0, LLVM(apple, google)</li>
    </ul>
  </li>
  <li>算法基本思想
    <ul>
      <li>每个非终结符构造一个分析函数（不一定严格对应）</li>
      <li>用前看符号指导产生式规则的选择</li>
      <li>使用了分治法的思想：divide and conquer</li>
    </ul>
  </li>
</ul>

<h3 id="示例-1">示例：</h3>

<ul>
  <li>
    <p>语法G:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S -&gt; N V N
N -&gt; s
   | t
   | g
   | w
V -&gt; e
   | d
</code></pre></div>    </div>
  </li>
  <li>
    <p>句子s：g d w</p>
  </li>
  <li>
    <p>代码：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_S()
  parse_N()
  parse_V()
  parse_N()

parse_N()
  token = tokens[i++]
  if (token == s || token == t || token == g || token == w)
    return
  error("s, t, g, w expected, but only found $token")

parse_V()
  token == tokens[i++]
  if (token == e || token == d)
    return
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="递归下降分析的一般算法框架">递归下降分析的一般算法框架</h3>

<ul>
  <li>
    <p>语法G:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x -&gt; b11 ... b1i
   | b21 ... b2j
   | b31 ... b3k
   | ...
</code></pre></div>    </div>
  </li>
  <li>
    <p>代码</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_X()
  token = nextToken()
  switch(token)
    case a1: b11 ... b1i
    case a2: b21 ... b2j
    case a3: b31 ... b3k
    default: error("...")
</code></pre></div>    </div>
  </li>
  <li>
    <p>重要问题：如果我们拿到了前看字符，如果有相同的起始字符，如何解决（case $a后有多种选择）</p>
  </li>
</ul>

<h3 id="对算数表达式的递归下降分析">对算数表达式的递归下降分析</h3>

<ul>
  <li>
    <p>语法G:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E -&gt; E + T
   | T
T -&gt; T * F
   | F
F -&gt; num
</code></pre></div>    </div>
  </li>
  <li>
    <p>代码:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// a first try
parse_E()
  token = tokens[i++]
  if (token == num)
    ? parse_E(); parse_T()
    ? parse_T();
    // 选用上述哪种不确定，还是需要回溯
  else error("...")
</code></pre></div>    </div>
  </li>
  <li>
    <p>通过分析文法的具体特点，充分利用可以进行优化。如此例中，我们注意到E开始生成时，
会生成T+T+T+T+…的形式，即T(+T)(+T)(+T)…的形式，故而我们可以先匹配T。
同理，F<em>F</em>F<em>F…我们也可以先匹配F，后匹配</em>。
这样就避免了上述如何匹配的问题。在具体文法分析的时候可以进行具体的思考。</p>
  </li>
  <li>
    <p>代码版本2：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// a second try
parse_E()
  parse_T()
  token = tokens[i++]
  while (token == +)
    parse_T()
    token = token[i++]
  
parse_T()
  parse_F()
  token = tokens[i++]
  while (token == *)
    parse_F()
    token = tokens[i++]
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h1 id="第五单元语法分析ii">第五单元：语法分析II</h1>

<ul>
  <li>语法分析器总的工作：<em>INPUT-记号流</em> –&gt; <strong>语法分析器</strong> –&gt; <em>OUTPUT-抽象语法树</em>，结合输入的语法G来判断记号流是否符合语法。</li>
  <li>我们可以手工来写语法分析器，如示例所示，也可以自动生成，类似词法分析器的自动生成。本节主要讨论语法分析器的自动生成。</li>
  <li>数学所具备的强大抽象能力使得我们在严格定义好概念的情况下，让很多工作可以自动完成。</li>
  <li>语法分析器例子：ANTLR, YACC, bison, SMLYACC</li>
</ul>

<h2 id="51-ll1分析算法antlr">5.1 LL(1)分析算法（ANTLR)</h2>

<h3 id="overview-3">Overview</h3>
<ul>
  <li>从左（L）向右读入程序，最左（L）推导，采用一个（1）前看符号（辅助判断）
    <ul>
      <li>分析高效（线性时间）</li>
      <li>错误定位和诊断信息准确</li>
      <li>有很多开源或商业的生成工具，如ANTLR</li>
    </ul>
  </li>
  <li>算法基本思想：<strong>表驱动的分析算法</strong></li>
</ul>

<h3 id="表驱动的ll分析器架构">表驱动的LL分析器架构</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**词法分析器** --记号--&gt; **语法分析器** --树--&gt;
                         |     |
                         |     |
                       分析栈   |
                               |
--语法--&gt;语法分析器/自动生成器--&gt;分析表
</code></pre></div></div>

<ul>
  <li>如上节分析，有时会出现符号不匹配的情况，在使用分析栈时就需要进行回溯，会导致效率降低</li>
  <li><strong>分析表</strong>：何时字符需要输入分析栈，何时输出，指导分析栈的工作</li>
</ul>

<h3 id="回顾自顶向下分析算法">回顾自顶向下分析算法</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> tokens[]          // 句子s在词法分析后所有tokens
  i = 0
  stack = [S]       // S是文法的开始符号
  while (stack != [])
    if (stack[top] is a terminal t)
      if (t == tokens[i++])
        pop();
      else backtrack()  --&gt; error           // 如果每次选择“正确”的右部，那么就不需要回溯了，要么匹配上，要么抛错
    else if (stack[top] is a nonterminal T)
      pop()
      push(the next right hand side of T)   // 从右向左开始压栈，其实是实现树的后序遍历
</code></pre></div></div>

<ul>
  <li>主要的问题在于最后一个next，目的在于遍历所有的可能。但不加选择地压入栈导致匹配不成功，只能回溯。因此我们需要压入“正确”的字符。</li>
  <li>如果每次坚持压入“唯一可能正确的右部”，但仍然有错误，那么就可以直接抛错了</li>
</ul>

<h3 id="ll1分析表">LL(1)分析表</h3>

<ul>
  <li>
    <p>语法G：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:  S -&gt; N V N
1:  N -&gt; s
2:     | t
3:     | g
4:     | w
5:  V -&gt; e
6:     | d
</code></pre></div>    </div>
  </li>
  <li>
    <p>分析表：</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">N\T</th>
      <th style="text-align: center">s</th>
      <th style="text-align: center">t</th>
      <th style="text-align: center">g</th>
      <th style="text-align: center">w</th>
      <th style="text-align: center">e</th>
      <th style="text-align: center">d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">N</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">V</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
    </tr>
  </tbody>
</table>

<p>N: 非终结符
T：终结符
数字：代表语法G的行号，从而指导应该压入什么元素进栈</p>

<h3 id="first集">First集</h3>

<ul>
  <li>定义：
FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符的集合</li>
</ul>

<h2 id="52-ll1分析的冲突处理">5.2 LL(1)分析的冲突处理</h2>

<h2 id="53-lr0分析算法">5.3 LR(0)分析算法</h2>

<h2 id="54-slr分析算法">5.4 SLR分析算法</h2>

<h2 id="55-lr1分析算法">5.5 LR(1)分析算法</h2>

<h2 id="56-lr1分析工具">5.6 LR(1)分析工具</h2>
:ET